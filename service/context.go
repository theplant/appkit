package service

import (
	"context"
	"fmt"
	"io"
	"net/url"
	"os"

	"github.com/hashicorp/vault/api"
	"github.com/jinzhu/configor"
	"github.com/pkg/errors"
	"github.com/theplant/appkit/credentials"
	"github.com/theplant/appkit/credentials/aws"
	"github.com/theplant/appkit/credentials/vault"
	"github.com/theplant/appkit/errornotifier"
	"github.com/theplant/appkit/log"
	"github.com/theplant/appkit/monitoring"
)

func serviceContext() (context.Context, io.Closer) {
	ctx := context.Background()

	serviceName := os.Getenv("SERVICE_NAME")

	logger, ctx := installLogger(ctx, serviceName)

	cfg := credentialsConfig(serviceName)

	vault, ctx := installVault(ctx, logger, cfg.Authn)

	ctx = installAWSSession(ctx, logger, cfg.AWSPath, vault)

	_, mC, ctx := installMonitor(ctx, logger, serviceName, vault)

	_, nC, ctx := installErrorNotifier(ctx, logger)

	return ctx, funcCloser{noopCloserF(func() {
		logger.Debug().Log(
			"msg", fmt.Sprintf("shutting down service context for %v", serviceName),
		)

		if vault != nil {
			logger.Debug().Log(
				"msg", "revoking vault token",
			)

			vault.Auth().Token().RevokeSelf("")
		}
	}), mC, nC}
}

func installLogger(ctx context.Context, serviceName string) (log.Logger, context.Context) {
	logger := log.Default()

	if serviceName == "" {
		logger.Warn().Log("msg", "creating service context, SERVICE_NAME not set")
	} else {
		logger = logger.With("svc", serviceName)
		logger.Info().Log(
			"msg", fmt.Sprintf("creating service context for %s", serviceName),
		)
	}

	return logger, log.Context(ctx, logger)
}

var noopCloser = noopCloserF(func() {})

////////////////////////////////////////////////////////////
// Metric Monitor

type influxDBConfig struct {
	URL string
}

func installMonitor(ctx context.Context, l log.Logger, serviceName string, vault *api.Client) (monitoring.Monitor, io.Closer, context.Context) {
	var monitor monitoring.Monitor
	var closer func()
	var u *url.URL

	config := influxDBConfig{}
	err := configor.New(&configor.Config{ENVPrefix: "INFLUXDB"}).Load(&config)
	if err != nil {
		goto err
	}

	if config.URL == "" {
		err = errors.New("blank influxdb url")
		goto err
	}

	u, err = url.Parse(config.URL)
	if err != nil {
		err = errors.New("error parsing influxdb url")
		goto err
	}

	// Direct: https://<username>:<pw>@<host>:<port>/<db>?service-name=<service_name>
	// Direct, stored in Vault, don't support this: vaultkv: INFLUXDB => <username>:<pw>@<host>:<port>/<db>?service-name=<service_name>
	// Generated by Vault: INFLUXDB => <username>:<pw>@<host>:<port>/<db>?service-name=<service_name>
	if u.Scheme == "vault" {
		// u.Path[0] is '/'...
		role := "database/creds" + u.Path + "-influxdb"

		l.Debug().Log(
			"msg", "fetching influxdb credentials from vault",
			"serviceName", serviceName,
			"role", role,
		)

		u.Scheme = "https"

		// username/pw from Vault
		if vault == nil {
			err = errors.New("no vault client")
			goto err
		}
		var secret *api.Secret
		secret, err = vault.Logical().Read(role)

		fmt.Println(secret, err)

		if err != nil {
			err = errors.Wrap(err, "error fetching credentials")
			goto err
		} else if secret == nil {
			err = errors.New("vault client returned nil secret")
			goto err
		}

		u.User = url.UserPassword(secret.Data["username"].(string), secret.Data["password"].(string))

		// hostname from url

		// DB name from url

		// service name
		q := u.Query()
		if q.Get("service-name") == "" && serviceName != "" {
			q.Set("service-name", serviceName)
		}

		u.RawQuery = q.Encode()

		config.URL = u.String()
	}

	monitor, closer, err = monitoring.NewInfluxdbMonitor(monitoring.InfluxMonitorConfig(config.URL), l)
	if err != nil {
		closer()
		goto err
	}

	return monitor, noopCloserF(closer), monitoring.Context(ctx, monitor)

err:
	l.Warn().Log(
		"msg", errors.Wrap(err, "falling back to log monitor: error creating influxdb monitor"),
		"err", err,
	)
	return monitoring.NewLogMonitor(l), noopCloser, ctx
}

////////////////////////////////////////////////////////////
// Error Notifier

func installErrorNotifier(ctx context.Context, l log.Logger) (errornotifier.Notifier, io.Closer, context.Context) {
	airbrakeConfig := errornotifier.AirbrakeConfig{}
	err := configor.New(&configor.Config{ENVPrefix: "AIRBRAKE"}).Load(&airbrakeConfig)
	if err != nil {
		panic(err)
	}

	n, closer, err := errornotifier.NewAirbrakeNotifier(airbrakeConfig)
	if err != nil {
		l.Warn().Log(
			"msg", errors.Wrap(err, "falling back to log error notifier: error creating airbrake notifier"),
			"err", err,
		)

		return errornotifier.NewLogNotifier(l), noopCloser, ctx
	}

	l.Info().Log(
		"msg", "creating airbrake notifier",
		"project_id", airbrakeConfig.ProjectID,
		"env", airbrakeConfig.Environment,
	)

	return n, closer, errornotifier.Context(ctx, n)
}

////////////////////////////////////////////////////////////
// Credentials: Vault, AWS

func credentialsConfig(serviceName string) credentials.Config {
	config := credentials.Config{}

	err := configor.New(&configor.Config{ENVPrefix: "VAULT"}).Load(&config)
	if err != nil {
		panic(err)
	}

	if serviceName := os.Getenv("SERVICE_NAME"); serviceName != "" {
		config = credentials.WithServiceName(config, serviceName)
	}

	return config
}

func installVault(ctx context.Context, l log.Logger, config vault.Config) (*api.Client, context.Context) {
	v, err := vault.NewVaultClient(l, config)
	if err != nil {
		panic(err)
	}

	return v, vault.Context(ctx, v)
}

func installAWSSession(ctx context.Context, l log.Logger, awsPath string, vault *api.Client) context.Context {

	awsSession, err := aws.NewSession(l, vault, awsPath)
	if err != nil {
		panic(err)
	}

	return aws.Context(ctx, awsSession)
}
